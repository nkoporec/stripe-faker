use clap::{arg, Command};
use fake::{faker::{name::en::{FirstName, LastName}, internet::en::SafeEmail}, Fake};
use stripe::{
    AttachPaymentMethod, CardDetailsParams, Client, CreateCustomer, CreatePaymentMethod,
    CreatePaymentMethodCardUnion, CreatePrice, CreatePriceRecurring, CreatePriceRecurringInterval,
    CreateProduct, CreateSubscription, CreateSubscriptionItems, Currency, Customer,
    IdOrCreate, PaymentMethod, PaymentMethodTypeFilter, Price, Product, Subscription,
};

fn args() -> Command {
    Command::new("stripe-faker")
        .about("Generate test data on Stripe")
        .subcommand_required(true)
        .arg_required_else_help(true)
        .allow_external_subcommands(true)
        .subcommand(
            Command::new("create-users")
                .about("Creates new users")
                .arg(arg!(<NUM_OF_USERS> "Number of users to generate."))
                .arg(
                    arg!(-s --subscription_create <SUBSCRIPTION_NAME>)
                        .num_args(0..=1)
                )
                .arg(
                    arg!(-c --credit_card <CREDIT_CARD_NUMBER>)
                        .num_args(0..=1)
                )
                .arg(
                    arg!(-k --secret_key <SECRET_KEY>)
                        .num_args(0..=1)
                ),
        )
}

#[tokio::main]
async fn main() {
    let matches = args().get_matches();

    match matches.subcommand() {
        Some(("create-users", sub_matches)) => {
            let empty_string = "".to_string();
            let num_of_users = sub_matches.get_one::<String>("NUM_OF_USERS").expect("required");
            let subscription_name = sub_matches.get_one::<String>("subscription_create").unwrap_or(&empty_string);
            let card = sub_matches.get_one::<String>("credit_card").unwrap_or(&empty_string);
            let secret_key = sub_matches.get_one::<String>("secret_key").unwrap_or(&empty_string);
            create_users_cmd(num_of_users, subscription_name, card, secret_key).await;
        }
        _ => unreachable!(),
    }
}

async fn create_users_cmd(num_of_users: &String, subscription_name: &String, card: &String, secret_key: &String) {
    let empty_string = "".to_string();
    let mut stripe_secret_key = std::env::var("STRIPE_SECRET_KEY").unwrap_or(empty_string);

    // Arg always have a higher priority.
    if secret_key.len() >= 1 {
        stripe_secret_key = secret_key.to_string();
    }

    if stripe_secret_key.len() <= 0 {
        println!("Missing STRIPE_SECRET_KEY. You can passed it by argument --secret_key or use a environment variable STRIPE_SECRET_KEY");
        return;
    }

    let client = Client::new(stripe_secret_key);

    // Create a new subscription.
    let mut price = Price::default();
    if !subscription_name.is_empty() {
        println!(" -- Creating a new subscription product --");

        let product = {
            let mut create_product = CreateProduct::new(subscription_name);
            create_product.metadata =
                Some([("async-stripe".to_string(), "true".to_string())].iter().cloned().collect());
            Product::create(&client, create_product).await.unwrap()
        };

        let stripe_price = {
            let mut create_price = CreatePrice::new(Currency::USD);
            create_price.product = Some(IdOrCreate::Id(&product.id));
            create_price.unit_amount = Some(1000);
            create_price.recurring = Some(CreatePriceRecurring {
                interval: CreatePriceRecurringInterval::Month,
                ..Default::default()
            });
            create_price.expand = &["product"];
            Price::create(&client, create_price).await.unwrap()
        };
        price = stripe_price;
    }

    let num = num_of_users.parse::<i32>().expect("Can't parse to i32");

    println!(" -- Creating fake users --");
    let mut i = 0;
    while i < num {
        let name = FirstName().fake::<String>() + " " + &LastName().fake::<String>();
        let email = SafeEmail().fake::<String>();

        // Create the user.
        let customer = Customer::create(
            &client,
            CreateCustomer {
                name: Some(&name),
                email: Some(&email),
                description: Some(
                    "A fake customer generated by stripe-faker.",
                ),
                ..Default::default()
            },
        )
        .await
        .expect("Failed to create a customer");

        // Attach a payment method.
        let mut payment_method = PaymentMethod{..Default::default()};
        if !card.is_empty() {
            payment_method = {
                let pm = PaymentMethod::create(
                    &client,
                    CreatePaymentMethod {
                        type_: Some(PaymentMethodTypeFilter::Card),
                        card: Some(CreatePaymentMethodCardUnion::CardDetailsParams(CardDetailsParams {
                            number: card.to_string(),
                            exp_year: 2035,
                            exp_month: 1,
                            cvc: Some("123".to_string()),
                            ..Default::default()
                        })),
                        ..Default::default()
                    },
                )
                    .await
                    .unwrap();

                PaymentMethod::attach(
                    &client,
                    &pm.id,
                    AttachPaymentMethod { customer: customer.id.clone() },
                )
                    .await
                    .unwrap();

                pm
            };
        };

        // Add the subscription.
        if !subscription_name.is_empty() {
            let _subscription = {
                let mut params = CreateSubscription::new(customer.id);
                params.items = Some(vec![CreateSubscriptionItems {
                    price: Some(price.id.to_string()),
                    ..Default::default()
                }]);
                params.default_payment_method = Some(&payment_method.id);
                params.expand = &["items", "items.data.price.product", "schedule"];

                Subscription::create(&client, params).await.unwrap()
            };
        }

        i += 1;
        println!("    --> Created user #{}, with name {}", i, name);
    }

    println!(" -- Successfully created {} amount of users --", num_of_users);
}
